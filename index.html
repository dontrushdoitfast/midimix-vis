<!--
    MIDImix Visualizer
    Copyright (c) 2025 Henry Chin (https://github.com/dontrushdoitfast)
    Licensed under the MIT License
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Midimix Visualizer</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- React & Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        :root {
            --bg-dark: #121212;
            --bg-panel: #18191a;
            --bg-strip: transparent;
            /* Strips are transparent for unified hardware look */
            --text-main: #eeeeee;
            --text-dim: #888888;
            --accent: #339af0;
            --border: #333;
            --knob-size: 40px;
            --fader-height: 120px;
            --gap-size: 4px;
        }

        * {
            box-sizing: border-box;
        }

        button,
        input,
        textarea {
            text-transform: inherit;
            font-family: inherit;
        }

        body {
            margin: 0;
            padding: 20px;
            background: var(--bg-dark);
            color: var(--text-main);
            font-family: 'Helvetica Neue', Arial, sans-serif;
            font-weight: 700;
            /* text-transform: uppercase; removed to enforce only on headers */
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Utility */
        .flex-col {
            display: flex;
            flex-direction: column;
        }

        .flex-center {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .gap-2 {
            gap: 8px;
        }

        .gap-4 {
            gap: 16px;
        }

        .text-truncate {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
            display: block;
        }

        /* Components */
        .app-header {
            width: 100%;
            max-width: 1000px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 10px 20px;
            background: var(--bg-panel);
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .btn {
            background: var(--bg-strip);
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn:hover {
            background: var(--border);
            color: white;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
            border: none;
        }

        .btn-primary:hover {
            opacity: 0.9;
        }

        /* BOARD LAYOUT */
        .board {
            display: flex;
            flex-direction: column;
            background: var(--bg-panel);
            padding: 20px;
            border-radius: 6px;
            border-top: 1px solid #333;
            border-bottom: 2px solid #000;
            box-shadow: 0 30px 60px rgba(0, 0, 0, 0.8);
            max-width: 1200px;
            width: 100%;
            position: relative;
            /* For screws */
        }

        /* Screws */
        .screw {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #333;
            border-radius: 50%;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.8), 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .screw::after,
        .screw::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #111;
        }

        .screw::after {
            width: 8px;
            height: 2px;
        }

        .screw::before {
            width: 2px;
            height: 8px;
        }

        .screw.tl {
            top: 8px;
            left: 8px;
        }

        .screw.tr {
            top: 8px;
            right: 8px;
        }

        .screw.bl {
            bottom: 8px;
            left: 8px;
        }

        .screw.br {
            bottom: 8px;
            right: 8px;
        }

        .grid-row {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            width: 100%;
        }

        /* Header Row specific styling */
        .headers-row {
            margin-bottom: 0;
            /* No gap between header and strip */
        }

        .header-cell {
            text-transform: uppercase;
            background: var(--bg-strip);
            padding: 8px 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-top: 4px solid transparent;
            /* Default to matching strip gap */
            border-right: 4px solid var(--bg-panel);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .header-cell.connected-right {
            border-right: 1px solid rgba(0, 0, 0, 0.2);
            margin-right: 0;
        }

        .header-cell:first-child {
            border-top-left-radius: 4px;
        }

        .header-cell:last-child {
            border-top-right-radius: 4px;
            border-right: none;
        }

        .strip {
            background: var(--bg-strip);
            /* border-radius: 0 0 4px 4px; */
            /* Bottom radius only */
            padding: 12px 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
            position: relative;
            /* Border Right handling for Gaps */
            border-right: 4px solid var(--bg-panel);
            /* Default Gap */
        }

        .strip.connected-right {
            border-right: 1px solid rgba(0, 0, 0, 0.2);
            /* Subtle divider */
            margin-right: 0;
        }

        .strip:last-child {
            border-right: none;
        }

        .strip-header {
            width: 100%;
            text-align: center;
        }

        .editable-input {
            background: transparent;
            border: 1px solid transparent;
            color: inherit;
            font-family: inherit;
            font-size: inherit;
            text-align: center;
            width: 100%;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .editable-input:hover {
            border-color: var(--border);
        }

        .editable-input:focus {
            border-color: var(--accent);
            background: rgba(0, 0, 0, 0.2);
            outline: none;
        }

        /* Custom Knobs */
        .knob-wrapper {
            position: relative;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .knob {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            position: relative;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5), inset 0 -2px 4px rgba(0, 0, 0, 0.4);
            transition: transform 0.1s;
        }

        /* Knob Variants */
        .knob.variant-black {
            background:
                repeating-linear-gradient(90deg,
                    #111 0px,
                    #111 2px,
                    #222 3px,
                    #222 4px);
            border: 1px solid #000;
        }

        .knob.variant-black::after {
            content: '';
            width: 3px;
            height: 45%;
            background: white;
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 1px;
        }

        .knob.variant-wood {
            background:
                repeating-linear-gradient(90deg,
                    #b08d55 0px,
                    /* Darker Base */
                    #b08d55 2px,
                    #e0c090 3px,
                    /* Lighter Ridge */
                    #e0c090 4px);
            border: 1px solid #8a6a3b;
        }

        .knob.variant-wood::after {
            content: '';
            width: 3px;
            height: 45%;
            background: white;
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 1px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .knob.variant-white {
            background: linear-gradient(135deg, #ffffff, #e0e0e0);
            border: 1px solid #ccc;
        }

        .knob.variant-white::after {
            content: '';
            width: 3px;
            height: 45%;
            background: #111;
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 1px;
        }

        /* Button Hardware Style */
        .btn-hw {
            width: 100%;
            height: 24px;
            background: #e0e0e0;
            /* White plastic */
            border: 1px solid #999;
            border-radius: 2px;
            box-shadow: 0 2px 0 #888;
            color: #333;
            font-size: 10px;
            font-weight: 800;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.1s;
        }

        .btn-hw:active {
            transform: translateY(2px);
            box-shadow: 0 0 0 #888;
        }

        .btn-hw.active {
            background: #ffffff;
            /* Lit/Active = Brighter White */
            color: #000;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.6), inset 0 0 5px rgba(255, 255, 255, 0.8);
            border-color: #fff;
        }

        .btn-hw.mute.active {
            background: #ffffff;
            /* Uniform white for all */
            color: #000;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.6), inset 0 0 5px rgba(255, 255, 255, 0.8);
            border-color: #fff;
        }

        .fader-track {
            width: 6px;
            height: var(--fader-height);
            background: #111;
            border-radius: 3px;
            position: relative;
            margin: 10px 0;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        .fader-cap {
            width: 40px;
            /* Wider cap */
            height: 18px;
            /* Shorter, flatter cap */
            background: linear-gradient(180deg, #333, #111);
            border: 1px solid #000;
            border-radius: 1px;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            cursor: ns-resize;
        }

        .fader-cap::after {
            content: '';
            position: absolute;
            top: 50%;
            margin-top: -1px;
            left: 2px;
            right: 2px;
            height: 2px;
            background: white;
            opacity: 0.5;
        }

        .label-sm {
            font-size: 11px;
            text-transform: uppercase;
            color: #ffffff;
            /* High contrast */
            font-weight: 700;
            margin-bottom: 2px;
            text-shadow: 0 1px 2px black;
        }

        /* Discrete Color Picker Styles */
        .color-popover-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 999;
            cursor: default;
        }

        .color-popover {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            background: #222;
            border: 1px solid #444;
            padding: 6px;
            border-radius: 4px;
            z-index: 1000;
            display: flex;
            gap: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .led-trigger {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.5), 0 0 2px rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
        }

        .led-trigger:hover {
            filter: brightness(1.2);
            box-shadow: 0 0 4px currentColor;
        }

        .file-input {
            display: none;
        }
    </style>
</head>

<body>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef, useMemo } = React;

        // --- Data Models & Defaults ---
        const COLORS = [
            '#2c2e33', // Default Dark
            '#d9480f', // Red
            '#2b8a3e', // Green
            '#1971c2', // Blue
            '#e67700', // Yellow
            '#862e9c', // Grape
        ];

        const DEFAULT_STRIP = {
            name: 'CH',
            color: COLORS[0],
            knob1: 'HI',
            knob2: 'MID',
            knob3: 'LO',
            btn1: 'MUTE',
            btn2: 'REC ARM',
            fader: 'VOL'
        };

        const getInitialData = () => ({
            strips: Array(8).fill(null).map((_, i) => ({ ...DEFAULT_STRIP, name: `CH ${i + 1}` })),
            master: {
                name: 'MASTER',
                color: COLORS[0],
                btn1: 'BANK L',
                btn2: 'BANK R',
                fader: 'MASTER'
            }
        });

        // --- Components ---

        const EditableText = ({ value, onChange, onShiftClick, className = '', style = {}, maxLength = 12 }) => {
            const [isEditing, setIsEditing] = useState(false);
            const [tempValue, setTempValue] = useState(value);
            const inputRef = useRef(null);

            useEffect(() => { setTempValue(value); }, [value]);
            useEffect(() => {
                if (isEditing && inputRef.current) inputRef.current.select();
            }, [isEditing]);

            const handleBlur = () => {
                setIsEditing(false);
                onChange(tempValue);
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter') handleBlur();
                if (e.key === 'Escape') {
                    setTempValue(value);
                    setIsEditing(false);
                }
            };

            if (isEditing) {
                return (
                    <input
                        ref={inputRef}
                        className={`editable-input ${className}`}
                        style={style}
                        value={tempValue}
                        onChange={(e) => setTempValue(e.target.value.slice(0, maxLength))}
                        onBlur={handleBlur}
                        onKeyDown={handleKeyDown}
                        maxLength={maxLength}
                        autoFocus
                    />
                );
            }

            return (
                <div
                    className={`editable-input text-truncate ${className}`}
                    style={{ ...style, cursor: 'text' }}
                    onClick={(e) => {
                        if (e.shiftKey && onShiftClick) {
                            onShiftClick();
                            return;
                        }
                        setIsEditing(true);
                    }}
                    title={onShiftClick ? "Click to edit, Shift+Click to split" : "Click to edit"}
                >
                    {value || '\u00A0'}
                </div>
            );
        };

        const DiscreteColorPicker = ({ selected, onSelect }) => {
            const [isOpen, setIsOpen] = useState(false);

            return (
                <div style={{ position: 'relative', display: 'flex', alignItems: 'center' }}>
                    {/* LED Trigger */}
                    <div
                        className="led-trigger"
                        style={{ background: selected || '#333', color: selected || '#333' }}
                        onClick={(e) => { e.stopPropagation(); setIsOpen(!isOpen); }}
                        title="Change Color"
                    />

                    {/* Popover */}
                    {isOpen && (
                        <>
                            <div className="color-popover-backdrop" onClick={(e) => { e.stopPropagation(); setIsOpen(false); }} />
                            <div className="color-popover">
                                {COLORS.map(c => (
                                    <div
                                        key={c}
                                        className="led-trigger" // reuse led style for dots
                                        style={{ width: '12px', height: '12px', background: c, borderColor: selected === c ? 'white' : 'transparent' }}
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            onSelect(c);
                                            setIsOpen(false);
                                        }}
                                    />
                                ))}
                            </div>
                        </>
                    )}
                </div>
            );
        };

        const Knob = ({ label, onChangeLabel, variant = 'variant-black' }) => (
            <div className="flex-col flex-center">
                <EditableText value={label} onChange={onChangeLabel} className="label-sm" style={{ color: '#fff', fontSize: '11px', fontWeight: 800, textShadow: '0 1px 2px black' }} />
                <div className="knob-wrapper">
                    <div className={`knob ${variant}`}></div>
                </div>
            </div>
        );

        // Header Cell Component for the Shared Header Row
        const HeaderCell = ({ title, color, span, onChangeTitle, onChangeColor, isConnectedRight, onSplit }) => {
            const getTint = (hex) => {
                if (!hex || hex === COLORS[0]) return 'transparent';
                const h = hex.replace('#', '');
                const r = parseInt(h.substring(0, 2), 16);
                const g = parseInt(h.substring(2, 4), 16);
                const b = parseInt(h.substring(4, 6), 16);
                return `rgba(${r},${g},${b},0.2)`;
            };

            const style = {
                gridColumn: `span ${span}`,
                background: color === COLORS[0] ? 'var(--bg-strip)' : getTint(color),
                borderTopColor: color === COLORS[0] ? 'transparent' : color,
                // If it's a default color, we want standard border behavior
                // The connected look is handled by the strip row below
            };

            return (
                <div className={`header-cell ${isConnectedRight ? 'connected-right' : ''}`} style={style}>
                    <div className="flex-center gap-2">
                        <EditableText
                            value={title}
                            onChange={onChangeTitle}
                            onShiftClick={span > 1 ? onSplit : undefined}
                            style={{ fontWeight: 600, fontSize: '14px' }} // removed marginBottom
                        />
                        <DiscreteColorPicker selected={color} onSelect={onChangeColor} />
                    </div>
                </div>
            );
        };

        const Strip = ({ data, updateStrip, isConnectedRight }) => {
            const setField = (field, val) => updateStrip({ ...data, [field]: val });

            const getTint = (hex) => {
                if (!hex || hex === COLORS[0]) return 'transparent';
                const h = hex.replace('#', '');
                const r = parseInt(h.substring(0, 2), 16);
                const g = parseInt(h.substring(2, 4), 16);
                const b = parseInt(h.substring(4, 6), 16);
                return `rgba(${r},${g},${b},0.2)`;
            };

            const bgStyle = data.color === COLORS[0]
                ? {}
                : { background: getTint(data.color) };

            return (
                <div className={`strip ${isConnectedRight ? 'connected-right' : ''}`} style={bgStyle}>
                    {/* Knobs */}
                    <div className="flex-col gap-4">
                        <Knob label={data.knob1} onChangeLabel={(v) => setField('knob1', v)} variant="variant-black" />
                        <Knob label={data.knob2} onChangeLabel={(v) => setField('knob2', v)} variant="variant-wood" />
                        <Knob label={data.knob3} onChangeLabel={(v) => setField('knob3', v)} variant="variant-white" />
                    </div>

                    {/* Buttons */}
                    <div className="flex-col gap-2" style={{ width: '100%' }}>
                        <button className="btn-hw mute active" onClick={(e) => e.target.classList.toggle('active')}>
                            <EditableText value={data.btn1} onChange={(v) => setField('btn1', v)} />
                        </button>
                        <button className="btn-hw active" onClick={(e) => e.target.classList.toggle('active')}>
                            <EditableText value={data.btn2} onChange={(v) => setField('btn2', v)} />
                        </button>
                    </div>

                    {/* Fader */}
                    <div className="fader-track">
                        <div className="fader-cap"></div>
                    </div>

                    <EditableText value={data.fader} onChange={(v) => setField('fader', v)} className="label-sm" />
                </div>
            );
        };

        // Reuse strip logic for Master but customized
        const MasterStrip = ({ data, updateMaster }) => {
            const setField = (field, val) => updateMaster({ ...data, [field]: val });
            const getTint = (hex) => {
                if (!hex || hex === COLORS[0]) return 'transparent';
                const h = hex.replace('#', '');
                const r = parseInt(h.substring(0, 2), 16);
                const g = parseInt(h.substring(2, 4), 16);
                const b = parseInt(h.substring(4, 6), 16);
                return `rgba(${r},${g},${b},0.2)`;
            };
            const bgStyle = data.color === COLORS[0]
                ? {}
                : { background: getTint(data.color) };

            return (
                <div className="strip" style={{ ...bgStyle, borderRight: 'none', borderRightWidth: '0' }}>
                    <div style={{ flex: 1 }}></div>

                    <div className="flex-col gap-2" style={{ width: '100%' }}>
                        <button className="btn-hw" onClick={(e) => e.target.classList.toggle('active')}>
                            <EditableText value={data.btn1} onChange={(v) => setField('btn1', v)} />
                        </button>
                        <button className="btn-hw" onClick={(e) => e.target.classList.toggle('active')}>
                            <EditableText value={data.btn2} onChange={(v) => setField('btn2', v)} />
                        </button>
                    </div>

                    <div className="fader-track" style={{ height: 'var(--fader-height)' }}>
                        <div className="fader-cap"></div>
                    </div>
                    <EditableText value={data.fader} onChange={(v) => setField('fader', v)} className="label-sm" />
                </div>
            )
        }


        // --- Main App Logic ---

        const App = () => {
            const [data, setData] = useState(getInitialData);
            const [isLoaded, setIsLoaded] = useState(false);
            const [resetKey, setResetKey] = useState(0);

            useEffect(() => {
                const saved = localStorage.getItem('midimix-setup');
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        if (!parsed.master.name) {
                            parsed.master = { ...parsed.master, name: 'MASTER', color: COLORS[0], btn1: 'BANK L', btn2: 'BANK R' };
                        }
                        setData(parsed);
                    } catch (e) { }
                }
                setIsLoaded(true);
            }, []);

            useEffect(() => {
                if (isLoaded) localStorage.setItem('midimix-setup', JSON.stringify(data));
            }, [data, isLoaded]);

            const updateStrip = (idx, newStrip) => {
                const newStrips = [...data.strips];
                newStrips[idx] = newStrip;
                setData({ ...data, strips: newStrips });
            };

            const updateMaster = (newMaster) => setData({ ...data, master: newMaster });

            const [confirmReset, setConfirmReset] = useState(false);

            useEffect(() => {
                if (confirmReset) {
                    const timer = setTimeout(() => setConfirmReset(false), 3000);
                    return () => clearTimeout(timer);
                }
            }, [confirmReset]);

            const handleReset = () => {
                if (confirmReset) {
                    setData(getInitialData());
                    setResetKey(prev => prev + 1);
                    setConfirmReset(false);
                } else {
                    setConfirmReset(true);
                }
            };

            const handleDownload = async () => {
                const jsonStr = JSON.stringify(data, null, 2);
                const filename = `midimix-setup-${new Date().toISOString().slice(0, 10)}.json`;
                if (window.showSaveFilePicker) {
                    try {
                        const handle = await window.showSaveFilePicker({ suggestedName: filename, types: [{ accept: { 'application/json': ['.json'] } }] });
                        const writable = await handle.createWritable();
                        await writable.write(jsonStr);
                        await writable.close();
                        return;
                    } catch (err) { }
                }
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            };

            const handleUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const json = JSON.parse(ev.target.result);
                        if (json.strips && json.master) {
                            setData(json);
                            setResetKey(prev => prev + 1);
                        }
                    } catch (err) { }
                };
                reader.readAsText(file);
                e.target.value = null;
            };

            // Calculation for Header Groups
            // We need to produce an array of cells for the header row
            // [ { type: 'strip', index: 0, span: 2 }, { type: 'master' ... } ]
            const headerGroups = useMemo(() => {
                const groups = [];
                let currentGroup = null;

                // Combine strips and master for calculation
                const allUnits = [...data.strips, { ...data.master, isMaster: true }];

                allUnits.forEach((unit, i) => {
                    if (!currentGroup) {
                        currentGroup = { name: unit.name, color: unit.color, indices: [i] };
                    } else {
                        if (unit.name === currentGroup.name) {
                            currentGroup.indices.push(i);
                        } else {
                            groups.push(currentGroup);
                            currentGroup = { name: unit.name, color: unit.color, indices: [i] };
                        }
                    }
                });
                if (currentGroup) groups.push(currentGroup);
                return groups;
            }, [data.strips, data.master]);


            // Handler for updating a group header
            const updateGroupHeader = (indices, newName, newColor) => {
                const newStrips = [...data.strips];
                let newMaster = { ...data.master };
                let masterUpdated = false;

                indices.forEach(idx => {
                    if (idx < 8) {
                        if (newName !== undefined) newStrips[idx].name = newName;
                        if (newColor !== undefined) newStrips[idx].color = newColor;
                    } else {
                        // Master
                        if (newName !== undefined) newMaster.name = newName;
                        if (newColor !== undefined) newMaster.color = newColor;
                        masterUpdated = true;
                    }
                });

                const updates = { strips: newStrips };
                if (masterUpdated) updates.master = newMaster;

                setData({ ...data, ...updates });
            };

            const splitGroup = (indices) => {
                if (confirm("Split this group?")) {
                    const newStrips = [...data.strips];
                    let newMaster = { ...data.master };
                    let masterUpdated = false;

                    // Append numbers to make them unique
                    indices.forEach((idx, i) => {
                        const unit = idx < 8 ? newStrips[idx] : newMaster;
                        const base = unit.name;
                        const newName = `${base.substring(0, 10)} ${i + 1}`;

                        if (idx < 8) {
                            newStrips[idx].name = newName;
                        } else {
                            newMaster.name = newName;
                            masterUpdated = true;
                        }
                    });

                    const updates = { strips: newStrips };
                    if (masterUpdated) updates.master = newMaster;
                    setData({ ...data, ...updates });
                }
            };


            return (
                <div className="flex-col items-center">
                    <header className="app-header">
                        <div className="flex-col">
                            <h1 style={{ margin: 0, fontSize: '20px', fontWeight: 700, color: 'white' }}>MIDImix<span style={{ color: 'var(--accent)', fontWeight: 300 }}>Visualizer</span></h1>
                            <span style={{ fontSize: '11px', color: '#666' }}>Hardware Mapping Visualiser</span>
                        </div>
                        <div className="flex-center gap-2">
                            <button
                                className="btn"
                                onClick={handleReset}
                                style={{ borderColor: confirmReset ? 'var(--accent)' : '' }}
                            >
                                {confirmReset ? 'Confirm Reset?' : 'Reset'}
                            </button>
                            <button className="btn" onClick={() => document.getElementById('upload').click()}>Load JSON</button>
                            <input id="upload" type="file" className="file-input" accept=".json" onChange={handleUpload} />
                            <button className="btn btn-primary" onClick={handleDownload}>Save JSON</button>
                        </div>
                    </header>

                    <div className="board" key={resetKey}>
                        <div className="screw tl"></div>
                        <div className="screw tr"></div>
                        <div className="screw bl"></div>
                        <div className="screw br"></div>

                        {/* 1. Header Row */}
                        <div className="grid-row headers-row">
                            {headerGroups.map((group, i) => {
                                // Connectivity Check for HEADER
                                const lastIndex = group.indices[group.indices.length - 1];

                                // Determine next unit color
                                let nextColor = null;
                                if (lastIndex < 8) {
                                    // if lastIndex is 7, next is Master (8)
                                    // if lastIndex is 8 (Master), next is null
                                    const nextIdx = lastIndex + 1;
                                    if (nextIdx < 8) nextColor = data.strips[nextIdx].color;
                                    else if (nextIdx === 8) nextColor = data.master.color;
                                }

                                const isConnected = nextColor && ((lastIndex < 8 ? data.strips[lastIndex].color : data.master.color) === nextColor);

                                return (
                                    <HeaderCell
                                        key={group.indices.join('-')}
                                        title={group.name}
                                        color={group.color}
                                        span={group.indices.length}
                                        onChangeTitle={(v) => updateGroupHeader(group.indices, v, undefined)}
                                        onChangeColor={(c) => updateGroupHeader(group.indices, undefined, c)}
                                        isConnectedRight={isConnected}
                                        onSplit={() => splitGroup(group.indices)}
                                    />
                                )
                            })}
                        </div>

                        {/* 2. Strips Row */}
                        <div className="grid-row strips-row">
                            {data.strips.map((s, i) => {
                                // Determine connectivity
                                // If i=7 (last strip), check against Master (fake index 8)
                                let nextColor = null;
                                if (i < 7) nextColor = data.strips[i + 1].color;
                                else if (i === 7) nextColor = data.master.color;

                                const isConnected = nextColor && (s.color === nextColor);

                                return (
                                    <Strip
                                        key={i}
                                        data={s}
                                        updateStrip={(d) => updateStrip(i, d)}
                                        isConnectedRight={isConnected}
                                    />
                                );
                            })}
                            <MasterStrip data={data.master} updateMaster={updateMaster} />
                        </div>
                    </div>

                    <footer style={{ marginTop: '40px', color: '#444', fontSize: '12px', textAlign: 'center' }}>
                        <p style={{ margin: '0 0 8px 0' }}>Midimix Visualizer &bull; Single File App &bull; No Server Required</p>
                        <p style={{ margin: 0, color: '#666' }}>To merge columns, name them the same. Shift+Click a header to unmerge.</p>
                    </footer>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

    </script>
</body>

</html>